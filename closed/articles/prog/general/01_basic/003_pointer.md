# ポインタを理解する
## はしがき
C言語の難関がポインタです。
ポインタを理解し使いこなすには若干想像力と慣れが必要ですね。
今回はそんなポインタについて簡単にまとめたいと思います。

<div class="outline"></div>

## ポインタの宣言
ポインタが難しい原因。
まずはっきり言ってC言語のポインタの文法が分かりにくいというのがあると思います。

下はポインタ変数を宣言する文の例です。
: int \*a;

整数型のポインタを宣言しています。
同じことは次のようにも書けます。
: int\* a;

微妙に違います。
C言語では同じ型の変数はカンマで区切って一度に宣言できます。
: int \*a, \*b, \*c;

これだと整数型のポインタを3個宣言したことになります。
しかし次のようだと違います。
: int \*a, b, c;

これだとポインタは最初のaだけで、bとcはただの整数です。

では
: int\* a, b, c;
だとどうでしょうか。
実はこれも同じでポインタは最初のaだけで、bとcはただの整数です。
てっきり型に`\*`がついたら後の変数は全てポインタになるのかと思ったら違ったということです。

というわけなんですけど分かりづらいですよね。まあ分かりづらいので私は今でもたまに調べます。

## ポインタにアドレス値を代入
ポインタは変数のアドレスを持っている変数です。
なのでポインタに値を代入する時はアドレスを代入しなくてはいけません。

: int a;      ← *整数型の変数aを宣言*
: int \*b;     ← *整数型のポインタbを宣言*
: b = &amp;a;     ← *bにaのアドレスを代入*

ではポインタbを通してaの値を変更してみます。

: *b = 1;

上の例ではaへのポインタbを使ってaに1を代入しています。

私はいつもここで「\*」をbの左に付けるか、右に付けるかで迷って今だに調べますが……。
正解は左です。

コーディング規約じゃないですがいっそ型に`\*`を付けるのは禁止した方が良いかもしれません。右か左かまぎらわしいので。

ポインタを使うには若干の想像力が必要と言いましたが、ここでbを通してaに値を代入しているというところに想像力がいると思います。初めてのおつかいみたいに自分が買い物をするんじゃなく子供に買いに行かせているようなイメージでしょうかね。ちょっと不安になりますね。知らんけど。

でもポインタが難しいのはここからで配列のポインタが難しいんですよね。

## ポインタ演算
### アドレスの値を加算する
整数の配列を宣言します。
: int a[10];
これで要素数が10の整数の配列aを宣言しました。

次に整数ポインタを宣言し、aのアドレスを代入します。
: int *b = a;
(配列のアドレスを渡す時は「&」を付けません。)

次にその値をひとつずつ代入していきます。

: for (int i = 0; i < 10; i++) {
:     \*b = i;
:     b = b + 1;
: }

上の例は配列aの要素に0から9までの値を一つずつ代入しています。

上の例で困るのは配列の添字を使わずにアドレス演算を使っていることです。
「b = b + 1」のところがそれですが、これはアドレスの値を加算しています。
1を足しているように見えるのですが、実は4足しています。
それは整数のサイズが4バイトだからです。

整数のサイズは基本的に4バイトですが、実装によって違う可能性もあります。
ですので「sizeof(int)」で調べて確認した方が良いでしょう。

まあそこにさえ気を付ければ良いのですが。

### 省略記法
上の例は次のように書くこともできます。
: for (int i = 0; i < 10; i++) {
:     \*b++ = i;
: }
後付けの`++`は計算が終わった後にアドレスを加算します。

ちなみにこれだとポインタが指している値を`++`で加算することはできないので注意が必要です。
ポインタが指している値を加算するには`(\*b)++`のように書きます。

## ヒープへのポインタ (最も普通な使い方)
別の使い方としては、ヒープに確保した領域へのポインタがあります。
C言語ってある意味型が自由なんですよね。
ヒープにはサイズの指定だけを行って、何の型とするかはポインタの型で決めます。
なのでヒープに確保するサイズはポインタが指す型のサイズと一致させなくてはいけません。

### ヒープに配列を作り、ポインタをローカル変数に持つ
例えば整数の配列をヒープに作る場合、整数のサイズ×要素数のサイズを指定します。
要素数100の整数の配列を作る場合は
: int \*a = malloc(sizeof(int) * 100);
とします。

整数のサイズは4バイトなので上の例では400バイトの領域をヒープに確保しました。

### ポインタの型変換 (配列から構造体へ)
ところで下のような構造体があるとします。
: struct Point {
:     int x, y;
: }
xとyという2つの整数を持っていて、サイズは合計で8バイトです。これは「sizeof(struct Poinst)」という式で確かめられます。

ここで「struct Point」型のポインタpを定義して、整数ポインタaのアドレスを代入します。
: struct Poinst \*p = (struct Point\*) a;

そしてpからaを参照してxとyの値を書き込みます。
: p->x = 1;
: p->y = 2;

こうするとa[0]の値が1になり、a[1]の値が2になるわけです。
つまり型は違いますが同じ領域を使っているからです。

### ポインタの型変換 (構造体から構造体へ)
上の例で出てきたstruct Pointをメンバに持つ別の構造体を考えてみます。
: struct TwoPoints {
:     struct Point p1;
:     struct Point p2;
: };

この構造体を`malloc`関数でヒープに作ってみます。
: struct TwoPoints *two\_points = malloc(sizeof(struct TwoPoints));

「struct Point」を2つもつ「struct TwoPoints」という構造体ですが、これを「struct Point」の配列として見ることができます。

: struct Point \*point = (struct Point\*) two_points;

こうすると「struct Point」として「struct TwoPoints」の値を変更できます。

: point->x = 1;
: point->y = 2;

このようにpointを通して代入した値をtwo\_pointsから読んでみます。

: printf("%d, %d\n", two\_points->p1.x, two\_points->p1.y);

結果、「1, 2」と出力されます。
これはpointとtwo\_pointsのメモリ領域が重なっていることでできることです。
何やってんだと思われるかもしれませんが、実はこれって良く使われるテクニックなんですよね。
特にウィンドウプログラミング(GUI)においては、ウィジェットと呼ばれる画面部品の操作の時に使う基本的なテクニックとなります。

## メモリの解放
ちなみにC言語では使い終わったヒープ領域は解放しなくてはなりません。
: free(two_points);

なおスタック領域のメモリは解放するとエラーになるので注意が必要です。
また一度解放したメモリを再度解放しようとした場合もエラーになりますのでこれも気をつけないといけません。

この一度確保した領域の解放し忘れがメモリリークというバグを引き起こします。
小さなプログラムでは問題ないのですが長時間稼動するプログラムにおいてメモリリークが蓄積すると困る場合もあるので注意が必要です。
とは言え人間不注意なものなのでプログラムが複雑になればなるほどメモリリークが起きる可能性はどんどん高くなりますし、必ず起きると言っても過言ではないでしょう。
メモリリークを検知するツールもあるので特に問題となる場合それを利用することを検討した方が良いです。
## NULL
NULL (ヌル) とは「空」という意味で実際には0のことです。
アドレス値0はプログラムでは参照できない領域となります。

そのため、ポインタが使われていないことを確認するためにあえてNULLを代入することがあります。

下はメモリを`free`関数で解放して使わなくなったポインタにNULLを代入する例です。

```NULLを代入する例
free(my\_pointer);
my\_pointer = NULL;
```

NULLを指すポインタをヌルポインター (通称ヌルポ) と言います。
ヌルポを参照すると実行時エラーとなります。

実行時エラー (ランタイムエラー) とはコンパイル時に露見せず実行してみて初めて分かるエラーのことです。
中でもヌルポインタエラーは絶対にあってはならないことなので、厳しくチェックしなくてはいけません。
: if (my_pointer == NULL) {
:     return;
: }
上のような「NULLチェック」と言う作業によりヌルポインタエラーが発生しないようにしましょう。

またこのNULLチェックのためには使わないポインタには必ずNULLを代入するようにしないとNULLチェックの意味がありませんのでそれも必要です。

`malloc`で確保されていない領域や`free`で解放した領域をポインタで参照するとこれもランタイムエラーとなりますので注意が必要です。

とは言えプログラムの構造上使われないと断言できるポインタにまでNULLをいちいち代入しなくても良いですが。

## 終わりに
C言語のポインタについて説明することはこれくらいだと思います。
