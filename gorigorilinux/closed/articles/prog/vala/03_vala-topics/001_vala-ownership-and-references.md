# Valaのメモリ管理 (参照)
**Vala**はオブジェクト指向プログラミング言語のひとつで、LinuxなどのUnix系・UnixライクなOSで使われている代表的なデスクトップ環境であるGNOMEを構成するGTK+ツールキットを使ったGUIアプリケーションの記述を簡単にできるように設計されています。
もちろんGTK+はクロスプラットフォームなのでGNOME以外の環境でも使うことができます。
今回はVala言語の仕様の中でも独特で少し難解なメモリ管理方法についてまとめました。

<div class="outline"></div>

## Valaのクラスと参照カウント
Valaではメモリを「参照カウント」によって管理しています。
Valaソースでクラスのインスタンスを生成した時には以下のような処理が行われます。

1. クラスからインスタンスを生成する。
2. そのインスタンスの参照カウントを1増やす。
3. インスタンスへの参照を変数に代入する。
4. 変数が使われなくなったら参照カウントを1減らす。
5. 参照カウントが0になった場合、そのインスタンスを削除する。

同じインスタンスへの参照を持つ変数は何個でも作ることができます。
変数から変数へインスタンスへの参照を渡した際にも参照カウントが1増えます。

以下に、`Dog`クラスを生成するValaのソースと、そこから変換されたC言語のコードを比較します。
<table class="diff">
<thead><tr><td>Vala</td><td>C言語(要約です)</td></tr></thead>
<tbody><tr><td>
```.vala
// インスタンスを生成する。
Dog pochi = new Dog();




// 別の変数に参照を渡す
Dog maruo = pochi;




// Dogのwanメソッド (ワンと鳴く)
// を実行
maruo.wan();













// 終わり
return;
```
</td><td>
```.vala
// インスタンスを生成する。
Dog *pochi = dog_new();

// 参照カウントを1で初期化する。
pochi->ref_count = 1;

// 別の変数に参照を渡す。
Dog *maruo = pochi;

// 参照カウントを1増やす。
maruo->ref_count++;

// Dogのwanメソッド (ワンと鳴く)
// を実行
dog_wan(maruo);

// 参照カウントを1減らす
poshi->ref_count--;

// 参照カウントを1減らす
maruo->ref_count--;

// 参照カウントが0に到達したら
// インスタンスを解放する。
if (maruo->ref_count == 0) {
    free(maruo);
}

// 終わり
return;
```
</td></tr></tbody>
</table>

どうでしょうか。Vala言語はC言語で行われているメモリ管理の詳細をかなり隠蔽できていることが見てとれると思います。
ちなみに、ValaのソースからCのソースを出力するには`valac`コマンドに`-C`オプションを付けて実行します。

: valac -C [ファイル名]

## 弱い参照
弱い参照 (weak reference) は参照を変数から変数に渡す時に参照カウントを増減させません。
弱い参照には何種類かありますが、ここでは`weak`と`unowned`についてまとめます。

### weakキーワード
`weak`キーワードと`unowned`キーワードは実のところ同じものですが、開発者によると`weak`キーワードはリンクリストなどで発生する「循環参照」が引き起こす「メモリリーク」防止のためのものだと思って欲しいそうです。
この循環参照の問題はウィキペディアにも記事が出ていますので詳しく解説しませんが、要するにお互いを参照する変数がある時、片方に`weak`キーワードを付ける必要があるということです。
[循環参照の問題点 | ウィキペディア](https://ja.wikipedia.org/wiki/%E5%8F%82%E7%85%A7%E3%82%AB%E3%82%A6%E3%83%B3%E3%83%88#%E5%BE%AA%E7%92%B0%E5%8F%82%E7%85%A7%E3%81%AE%E5%95%8F%E9%A1%8C%E7%82%B9)
これは参照カウント方式の弱点を補うための仕様なので、循環参照構造自体なるべく使わないことが推奨されることになると思います。
私たちがValaを使って作りたいのはデスクトップアプリケーションなので、循環参照が生じるような複雑な構造を使いたいときはlibGeeの`LinkedList`を使うなどするのが安全簡単だと思われます。

```_双方向リンクリスト (Doubly linked list) の例です.vala
class DoublyLinkedList<T> {
    private DoublyLinkedList next;
    private weak DoublyLinkedList prev;
    public T data { get; set; }

    public DoublyLinkedList(DoublLinkedList prev) {
        // 前の要素にとっての次の要素は参照カウンタを増やす
	prev.next = this;
	
	// この要素にとっての前の要素は参照カウンタを増やさない
        this.prev = prev;
    }
}
```

### unownedキーワード
フィールドを持つオブジェクトはオブジェクトが削除されるのと同時にフィールドのオブジェクトも削除しようとしますが、フィールドを参照している別の変数がある場合、参照カウントが0にならないので削除されません。
オブジェクト削除のタイミングでフィールドも全て削除したい場合は、ゲッターメソッドに`unowned`キーワードを付けてフィールドへの参照を返します。
```.vala
// 人クラス
class Human : Object {
    // タトゥー
    private Tatoo tatoo

    // 人のタトゥーへの参照
    public unowned Tatoo get\_tatoo() {
    	   return tatoo;
    }
}
```
このように定義したクラスのインスタンスから`tatoo` (タトゥー) を参照したい場合
```.vala
unowned Tatoo his\_tatoo = john.get\_tatoo();
```
というようにします。
ローカル変数`his\_tatoo`は`unowned`なので、`john.tatoo`の参照カウントが増減しません。
こうするとジョンが消えるのと同時にタトゥーも消えます。
ジョンが消えたのにタトゥーだけ残っていると変ですからね。

逆にジョンが消えてもタトゥーだけ残したい場合は`unowned`を付けないようにします。

はっきり言ってここら辺ややこしいので、上に挙げたような例以外では使わず、オブジェクトの管理は参照カウント機能に任せた方が良いでしょうね。プログラミングしている時は忙しいのでこのような細かいことは気にしていられません。

### プロパティ
Valaのクラスはフィールドとは別にプロパティというものを設定できますが、これはデフォルトで弱い参照になります。
```.vala
// 人クラス
class Human : Object {
    // 口 (プロパティ)
    public Mouth mouth { get; set; }

    // 耳 (プロパティ)
    public Ear ear { get; set; }

    public Human() {
        mouth = new Mouth();
	ear = new Ear();
    }
}
```
このようなクラスがある時、人の口や耳はプロパティとしてフィールドのように参照できますが、弱参照なので外部から参照する変数は参照カウントを増減させません。
そのため、耳や口は持ち主の人が消えるのと同時に消えます。

## ポインタ
ValaではC言語のようなポインタを使うこともできます。
ポインタにインスタンスへの参照を代入。
```.vala
Dog *dog = new Dog();
```
ポインタからインスタンスのメソッドを実行
```.vala
dog->wan();
```
削除する時
```.vala
delete dog;
```

変数から変数へ参照を渡す時
```.vala
Dog dog = new Dog();
Dog *dog_ptr = dog;
```
上の例2行目は`unowned`の場合と同じく、参照カウントは増減しません。
そのため、2番目以降のポインタに対して`delete`をする必要はありません (すると実行時エラーになります)。

ポインタは自分でコーディングをする際には使う必要はありません。
必要になるのはC言語で書かれたライブラリを使う時です。
例えばlibxml2のノードオブジェクトはGTKのオブジェクトではないのでポインタで扱います。
しかし、それもVala向けのバインディングがあれば必要なくなります。

## 参照渡し
関数やメソッドに変数の参照を渡すと、引数を戻り値として使えるようになります。
参照渡しには`out`キーワードか`ref`キーワードを付けます。

### outキーワード
`out`を付けて渡した変数はメソッド内部で初期化されます。
戻り値として使うことができます。
C言語で言えば`scanf`などの引数と同じイメージです。

よくあるケースとしては
* 戻り値が複数ある場合
* 戻り値が構造体 (ヒープにない) の場合
という場合に使われます。

```_構造体に値を設定する例.vala
// RGB色の構造体
struct Color {
    public int red;
    public int green;
    public int blue;
}

// 色に白を設定する関数
void set_white(out Color color) {
    color.red = 255;
    color.green = 255;
    color.blue = 255;
}

// 呼び出し側
void main() {
    Color color;
    set_white(out color); // => colorに{255,255,255}が設定されている
}
```

### refキーワード
`ref`を付けて渡す変数は初期化済みである必要があります。
よくあるケースとしては
* リストやツリー構造のイテレータを更新する
という場合に使います。
```_プレイリストの中を走査する例.vala
// 曲名がプレイリストにあるか確認するメソッド
bool music\_exists(string name) {
    Gtk.TreeStore store = (Gtk.TreeStore) playlist\_tree.model;
    if (store.iter\_has\_child(playlist\_root)) {
        Gtk.TreeIter iter;

	// ↓イテレータを初期化する為にoutを使っている。
        store.iter\_children(out iter, playlist\_root);
        do {
	    // プレイリストの中を検索する処理
            GLib.Value val;

	    // ↓Valueは構造体なのでoutで結果を受け取る
            store.get\_value(iter, 1, out val);
            string val\_name = (string) val;

	    // ↓曲名が見つかったらtrueを返す
            if (val\_name == name) {
                return true;
            }
        } while (store.iter\_next(ref iter));
	// ↑ イテレータの更新にrefを使っている
    }
    return false;
}
```
これもややこしいのですが、APIが`ref`や`out`を要求している場合は使うしかありません。
自分で作る時もどうしても必要という時以外、積極的に使うものではないですね。

この機能はC#を真似したものっぽいです。
C#の記事によくまとまっているものがありました。
[C# out と ref @muro | Qiita 2016.08.16](https://qiita.com/muro/items/f88b17b5fea3b4537ba7)
## まとめ
いかがでしたか。
ややこしい話になってしまいましたが、基本的に例外的規則になるのであまり使うことはない弱参照についての話がほとんどになりました。まとめるとこのようになります (※個人の感想です)。

1. **weak**: オブジェクトは基本的にツリー構造にすることで循環参照が発生しないように気を付けます。
2. **unowned**: オブジェクトの持ち主から離れないようにしたい時には`unowned`を使います。(ほとんどないですが)
3. **プロパティ**: オブジェクトの設定値などはプロパティを使います。(これが最も使います。)
4. **ポインタ**: C言語のライブラリを呼び出す時に使います。
5. **out引数**: 戻り値の代わりに使います。(構造体に値を設定する場合だけですが)
6. **ref引数**: イテレータの更新で使う場合があります。

以上になります。
